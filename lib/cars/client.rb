# Author:		Chris Wailes <chris.wailes@gmail.com>
# Project: 	Chris's Advanced RPC Suite
# Date:		2012/04/05
# Description:	This file contains the RPC client code.

############
# Requires #
############

# Standard Library
require 'net/http'
require 'uri'

# CARS
require 'rpc'

#######################
# Classes and Modules #
#######################

module CARS
	# RPC clients are used to access the procedures exposed by XML-RPC servers
	# This particular client supports many different features, and two
	# different ways of calling remote procedures.
	#
	# The first way of calling a procedure is to use the call method.  The
	# second method is to use the proxy functionality of a client instance.
	#
	# When a CARS::Client object receives a message (in the Ruby sense of
	# method calls) it doesn't recognize it returns a proxy object that can be
	# used to make calls.  This works by either explicitly using the
	# CARS::Client::Proxy.call method or by subsequent method calls to the
	# Proxy object that aren't implemented by the Object class.
	#
	# Examples:
	#	client.call('math.multiply', 4, 5, 6)
	#	client.math.multiply(4,5,6)
	class Client
		
		# The most basic way to make a remote procedure call.  Simply pass
		# the name of the procedure as the first parameter and then any
		# additional parameters will be sent to the server as arguments of
		# the procedure call.
		def call(procedure, *args)
			response = sendRequest(@parser.toXML(RPC.new(procedure, *args)))
			result = @parser.fromXML(response)
			
			if result.is_a?(IRE::RPCFault)
				raise result
			else
				result.first
			end
		end
		
		# The address may be either a string representing the address of the
		# server (e.g. http://example.com:3000/rpc) or a URI::HTTP or
		# URI::HTTPS object.  Additional arguments are:
		# * parser - The XML parser to use.  Either :libxml or :rexml. :libxml is the default.
		# * zip - Whether or not to zip output and accept zipped input.  True or false. (Default: false)
		# * zip_level - The level of zipping to be done. 1-9 (Default: 9)
		# * zip_threshold - Anything below this number (in bytes) will not be zipped if zipping is enabled. (Default: 524288 a.k.a. 500KiB)
		# * timeout - The timeout (in seconds) to be used for http requests. (Default: 30)
		def initialize(address, options = {})
			setAddress(address)
			
			@parser =
			if options[:parser] == :rexml
				require 'rexml_parser'
				REXMLParser.new()
			else
				require 'libxml_parser'
				LibXMLParser.new()
			end
			
			@zip =
			if options[:zip]
				require 'zipper'
				true
			else
				false
			end
			
			@zip_level = options[:zip_level] || 9
			@zip_threshold = options[:zip_threshold] || 524288
			@timeout = options[:timeout] || 30
		end
		
		# Use this method to change the address of the client.  It can be
		# called at any time and accepts the same type of arguments as the
		# address parameter of new.
		def set_address(address)
			@address =
			if address.is_a?(URI::HTTP) or address.is_a?(URI::HTTPS)
				address
				
			elsif address.is_a?(String)
				URI.parse(address)
				
			else
				raise 'Invalide address.'
			end
			
			@address.path = '/' if @address.path == ''
			
			@http			= Net::HTTP.new(@address.host, @address.port)
			@http.read_timeout	= @timeout
			@http.use_ssl		= true if @address.scheme == 'https'
		end
		
		private
		def send_request(xml)
			header					= Hash.new
			header['Accept']			= 'text/xml,application/xml'
			header['Content-Type']		= 'text/xml'
			header['Accept-Encoding']	= header['Content-Encoding'] = 'gzip' if @zip
			
			request = Net::HTTP::Post.new(@address.path, header)
			request.basic_auth = @address.userinfo.split(/:/) if @address.userinfo
			
			response = @http.request(request, if @zip and xml.length >= @zip_threshold then Zipper.zip(xml, @zip_level) else xml end)
			
			if response['Content-Encoding'] == 'gzip'
				Zipper.unzip(response.body)
				
			else
				response.body
			end
		end
		
		def method_missing(name, *args)
			if args.empty?
				Proxy.new(self, name.to_s)
				
			else
				self.call(name.to_s, *args)
			end
		end
		
		# The Proxy class is used internally by the Client class to provide
		# an alternate way to make remote procedure calls.  You can also save
		# proxies that are generated by a client and use them later.
		# Example:
		#	proxy = client.math
		#	proxy.multiply(2, 4)
		#	proxy.add(5, 6)
		class Proxy #:doc:
			
			# Used to explicitly tell a proxy to send the procedure call.
			def call(*args)
				@client.call(@proxyProcedure, *args)
			end
		
			def initialize(client, name)
				@client			= client
				@proxy_procedure	= name
			end
			
			private
			def method_missing(name, *args)
				
				# We build a new proxy object so that people can save
				# partial calls and use them later.
				next_proxy = Proxy.new(@client, @proxy_procedure + '.' + name.to_s)
				
				if args.empty?
					next_proxy
				else
					next_proxy.call(*args)
				end
			end
		end
	end
end
